## UVa 12108 Extraordinarily Tired Students
বইয়ে একটা শর্ত বাদ দেয়া হয়েছে। তা হল প্রত্যেকে ঘুমাতে যাওয়ার আগে গুনে দেখে কতজন জেগে আছে। যদি দেখা যায় বেশিরভাগ স্টুডেন্টই ঘুমিয়ে আছে তাহলে সেও ঘুমাতে চলে যাবে।
না হলে সে আরো a সময় জাগবে। অর্থাৎ তার awaken-sleeping period এর প্রথম অবস্থায় চলে যাবে।

প্রত্যেক স্টুডেন্টের অবস্থা status অ্যারেতে রাখব। তারপর সব স্টুডেন্টের awaken-sleeping period এর দৈর্ঘের ল সা গু পর্যন্ত t এর লুপ চলিয়ে দেখব কতজন স্টুডেন্ট জেগে আছে। যদি সবাই
জেগে থাকে তাহলে ত হলই। না থাকলে সবার পরবর্তী অবস্থা কি হবে তা status অ্যারেতে লিখে রাখব।
  * [কোড](CH02-Easy-Problems/UVa12108.cpp)

## UVa 253 Cube painting
কিউবটাকে X এবং Z অ্যাক্সিসে ঘুরানোর জন্য দুইটা ফাশংন লিখব। এইগুলা কম্বাইন করে Y এক্সিসেও ঘুরানো যাবে। এখন লুপের মাধ্যমে ঘুরিয়ে ঘুরিয়ে একটা কিউবকে যতভাবে রাখা যায় (২৪ ভাবে) রাখব এবং
দেখব অন্যটার মত সেইম হল কি না।
  * [কোড](CH02-Easy-Problems/UVa253.cpp)

## Timus 1005 Stone Pile

* __ব্যাকট্র্যাক :__ এইটাই মনে হয় সবার আগে মাথায় আসে। আইডিয়াটা হল প্রত্যেক সংখ্যায় গিয়ে ঐ সংখ্যা নিয়ে এবং না নিয়ে পরের সংখ্যায় যেতে হবে। এভাবে শেষ সংখ্যায় এসে দেখতে হবে যোগফল কত হয়। এটা যদি একটা গ্রুপের যোগফল হল তাহলে অন্য গ্রুপের যোগফলের জন্য মোট থেকে বাদ দিতে হবে। তারপর দুই গ্রুপের বিয়োগফল নিয়ে ans আপডেট করতে হবে।           
  * [O(2^n) কোড](/CH02-Easy-Problems/Timus1005/backtrack.cpp)

* __কয়েন চেন্জ ডিপি :__ এখানে একটি গ্রুপের সর্বোচ্চ যোগফল হতে পারে সবগুলো সংখ্যার যোগফল পর্যন্ত। তাহলে আমরা ১ থেকে লুপ চালিয়ে প্রত্যেকটি সংখ্যায় গিয়ে দেখব প্রদত্ত
সংখ্যাগুলো একবার ব্যবহার করে সংখ্যাটি বানানো যায় কি না। এজন্য আমরা কয়েন চেন্জ ডিপি ব্যবহার করব। যদি যায় তাহলে ঐ সংখ্যাটিকে একটি গ্রুপের যোগফল ধরে ans আপডেট করব।
  * [O(total) কোড](/CH02-Easy-Problems/Timus1005/coin-change-dp.cpp)

* __বিটমাস্ক :__ আমরা যদি 1 থেকে 2^n পর্যন্ত সবগুলো সংখ্যার বাইনারি নিই তাহলে n সংখ্যক ০ আর ১ এর যত রকম কম্বিনেশন হতে পারে সবগুলো পাব। তাহলে আমারা যদি i তম সংখ্যায় গিয়ে এর j তম বিট 1 হলে প্রদত্ত সংখ্যাগুলোর j তম সংখ্যা প্রথম গ্রুপে নিই তাহলে কিন্তু প্রথম গ্রুপের যত রকম যোগফল হতে পারে সেগুলো পাব। তাহলে ০ থেকে 2^n পর্যন্ত প্রতি
সংখ্যায় গিয়ে ঐ সংখ্যার বিট রিপ্রেজেন্টেশন অনুসারে যোগফল নিয়ে ans আপডেট করলে ফাইনাল ans পাওয়া যাবে। যদিও কম্প্লেক্সিটি _ডিপি_ থেকে বেশি, ব্যাপারটা ইন্টারেস্টিং :+1:
  * [O(n * 2^n) কোড](/CH02-Easy-Problems/Timus1005/bitmask-low-mem.cpp)
  
* __বিটমাস্কের সাথে মেমোরাইজেশন :__ আগের এপ্রোচে প্রতি বিটে গিয়ে দেখতে হচ্ছে j তম সংখ্যা নেব কি না। এজন্য কম্প্লেক্সিটি হয়ে যাচ্ছে n * 2^n। এখান থেকে n বাদ দেয়া সম্ভব। প্রতি সংখ্যায় গিয়ে যদি আমরা তার একটি অন বিট অফ করে দেই তাহলে কিন্তু সংখ্যাটি আগের থেকে ছোট হয়ে যাচ্ছে। ঐ সংখ্যার জন্য কিন্তু যোগফল আমরা আগেও বের করেছি। এখন যদি আগেরটা কোন অ্যারেতে সেভ করে রাখতাম তাহলে ঐটার সাথে যততম বিটটি অফ করেছি প্রদত্ত সংখ্যার তততম সংখ্যাটি যোগ করে দিলেই কিন্তু বর্তমান সংখ্যার জন্য যোগফল পেয়ে যেতাম। এখন একটু খেয়াল করলে দেখা যাবে 2^i থেকে 2^i - 1 সংখ্যাগুলোর i তম বিট সব সময় অন থাকে। তাহলে এভাবে আমরা n * 2^n থেকে n বাদ দিতে পারি। কিন্তু তাহলে আবার
2^n সাইজের অ্যারে লাগছে। সুতরাং মেমরি কম্প্লেক্সিটি বেড়ে যাচ্ছে।
  * [O(2^n) বিটমাস্ক কোড](/CH02-Easy-Problems/Timus1005/bitmask-with-memorization.cpp)
