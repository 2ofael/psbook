/**
 * Problem: Timus 1005 - Stone Pile
 * Author: sjsakib
 * Approach: bitmask with memorization
 * Time: O(2^n)
 * Memory: O(2^n)
 * আগের এপ্রোচে প্রতি বিটে গিয়ে দেখতে হচ্ছে j তম সংখ্যা নেব কি না। এজন্য কম্প্লেক্সিটি হয়ে যাচ্ছে n * 2^n। এখান থেকে n বাদ দেয়া সম্ভব। প্রতি সংখ্যায় গিয়ে যদি আমরা তার একটি অন বিট অফ করে দেই তাহলে কিন্তু সংখ্যাটি আগের থেকে ছোট হয়ে যাচ্ছে। ঐ সংখ্যার জন্য কিন্তু যোগফল আমরা আগেও বের করেছি। এখন যদি আগেরটা কোন অ্যারেতে সেভ করে রাখতাম তাহলে ঐটার সাথে যততম বিটটি অফ করেছি প্রদত্ত সংখ্যার তততম সংখ্যাটি যোগ করে দিলেই কিন্তু বর্তমান সংখ্যার জন্য যোগফল পেয়ে যেতাম। এখন একটু খেয়াল করলে দেখা যাবে 2^i থেকে 2^i - 1 সংখ্যাগুলোর i তম বিট সব সময় অন থাকে। তাহলে এভাবে আমরা n * 2^n থেকে n বাদ দিতে পারি। কিন্তু তাহলে আবার
 * 2^n সাইজের অ্যারে লাগছে। সুতরাং মেমরি কম্প্লেক্সিটি বেড়ে যাচ্ছে।
**/
#include <bits/stdc++.h>

using namespace std;

int n, num[22], sum=0, ans;

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &num[i]);
        sum += num[i];
    }
    ans = sum;
    int mem[(1<<n) + 10];
    mem[0] = 0;
    for (int i = 0; i < n; i++) {
        for (int mask = 1<<i; mask < (1<<(i+1)); mask++) {
            mem[mask] = mem[mask ^ (1<<i)] + num[i];
            ans = min(ans, abs((sum - mem[mask]*2)));
        }
    }
    printf("%d\n",ans);
    return 0;
}